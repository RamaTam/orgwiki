<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ch" xml:lang="ch">
<head>
<title>模型视图矩阵</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="模型视图矩阵"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-10-18 14:49:15 CST"/>
<meta name="author" content="Joseph Pan"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="stylesheet" href="./other/style.css" type="text/css"/>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="org-div-home-and-up" style="text-align:right;font-size:70%;white-space:nowrap;">
 <a accesskey="h" href="./opengl_index.html"> UP </a>
 |
 <a accesskey="H" href="./index.html"> HOME </a>
</div>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">模型视图矩阵</h1>


<script type="text/javascript" src="./other/mathjax/MathJax.js?config=TeX-AMS_HTML"></script>

<p>
   模型视图矩阵是个\(4\times 4\)的矩阵，代表经过变换的坐标系统，我们可以用这个坐标系统放置物体并设置其方向。我们为图元所提供的顶点将按照单列矩阵（也就是一个向量）的形式使用，并乘以一个模型视图矩阵，将产生与视觉坐标系统相对应的经过变换的新坐标。
</p>
<p>
   示例：一个包含了单个顶点数据的矩阵与模型视图矩阵相乘，产生了新的视觉坐标。这个顶点数据实际上由4个元素表示，包括那个 <b>额外的表示缩放因子的</b> \(\omega\) <b>值</b> 。这个值在默认情况下设置为1.0，我们很少需要自己修改这个值。
</p>
<p>
\[\begin{bmatrix} X \\ Y \\ Z \\ \omega \end{bmatrix}\begin{bmatrix} 4 \times 4 \\ M \end{bmatrix}=\begin{bmatrix}X_0 \\ Y_0 \\ Z_0 \\ W_0 \end{bmatrix}\]
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 构造模型视图矩阵</a>
<ul>
<li><a href="#sec-1-1">1.1 单位矩阵</a></li>
<li><a href="#sec-1-2">1.2 平移</a></li>
<li><a href="#sec-1-3">1.3 旋转</a></li>
<li><a href="#sec-1-4">1.4 缩放</a></li>
<li><a href="#sec-1-5">1.5 综合变换</a></li>
</ul>
</li>
<li><a href="#sec-2">2 运用模型视图矩阵</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 构造模型视图矩阵</h2>
<div class="outline-text-2" id="text-1">


<p>
  OpenGL在表示一个\(4\times 4\)的矩阵时并没有使用浮点型的二维数组，而是用了一个包含16个浮点值的一维数组来表示。这个方法和许多数学函数库所使用的方法不同，后者常常采用二维数组来表示矩阵。例如，在下面这两个例子中，OpenGL更倾向于使用前者。
</p>



<pre class="src src-c"><span style="color: #00ffff; font-weight: bold;">GLfloat</span> <span style="color: #ffd700; font-style: italic;">matrix</span>[16];     <span style="color: #ffd700;">// </span><span style="color: #ffd700;">OpenGL&#25152;&#37319;&#29992;&#30340;&#21451;&#22909;&#30697;&#38453;</span>
<span style="color: #00ffff; font-weight: bold;">GLfloat</span> <span style="color: #ffd700; font-style: italic;">matrix</span>[4][4];   <span style="color: #ffd700;">// </span><span style="color: #ffd700;">&#26356;&#20026;&#27969;&#34892;&#65292;&#20294;&#19981;&#22914;OpenGL&#25152;&#37319;&#29992;&#30340;&#26041;&#24335;&#39640;&#25928;</span>
</pre>


<p>
  OpenGL也可以使用第二种类型的表示形式，但第一种类型更为高效。其中的缘由很快就会变得更清楚。这16个元素代表一个\(4\times 4\)的矩阵，如下所示。
</p>
<p>  
  \[\begin{bmatrix} a_0 &amp; a_4 &amp; a_8 &amp; a_{12} \\ a_1 &amp; a_5 &amp; a_9 &amp; a_{13} \\ a_2 &amp; a_6 &amp; a_{10} &amp; a_{14} \\ a_3 &amp; a_7 &amp; a_{11} &amp; a_{15} \end{bmatrix}\]
</p>
<p>  
  当我们按列逐个遍历数组中的元素时，就称为列主序的矩阵顺序。在内存中，用二维数组表示的\(4\times 4\)矩阵是以行主序存储的。这两种方向之间是转置关系。
</p>
<p>  
  真正的奥秘在于这16个值表示空间中 <b>一个特定的位置和三个轴的方向</b> 。
</p>
<p>  
  下面是一个变换矩阵的例子：
</p>
<p>
\[\begin{bmatrix} X_x &amp; Y_x &amp; Z_x &amp; T_x \\ X_y &amp; Y_y &amp; Z_y &amp; T_y \\ X_z &amp; Y_z &amp; Z_z &amp; T_z \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}\]
</p>
<ul>
<li>前三列：方向向量，表示空间中x、y和z轴的方向。在绝大多数情况下，这3个向量相互之间呈90°垂直（正交）。
</li>
<li>最后一列：经过变换的坐标系统的x、y和z值。

<p>  
  最奇妙的是：如果一个\(4\times 4\)的矩阵包含了一个不同的坐标系统的位置和方向。那么，把一个顶点（以一个列矩阵或向量的形式）与这个矩阵相乘，其结果就是一个变换到该坐标系统的新顶点。这意味着空间中的任何位置以及自己所需要的任何方向都可以通过一个\(4\times 4\)的矩阵进行唯一的定义，并且，如果把一个物体的所有顶点与这个矩阵相乘，就可以把整个物体变换到空间中指定的位置和方向！
</p></li>
</ul>



</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 单位矩阵</h3>
<div class="outline-text-3" id="text-1-1">


<p>
  有一些重要类型的变换矩阵，在我们开始尝试使用它们之前，首先要熟悉它们。第一个就是单位矩阵，将一个向量乘以一个单位矩阵，就相当于用这个向量乘以1，不会发生改变。
</p>
<p>  
  \(\begin{bmatrix} 8.0 \\ 4.5 \\ -2.0 \\ 1.0 \end{bmatrix}\begin{bmatrix} 1.0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1.0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1.0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1.0 \end{bmatrix}=\begin{bmatrix}  8.0 \\ 4.5 \\ -2.0 \\ 1.0 \end{bmatrix}\)
</p>
<p>
  使用单位矩阵绘制的对象不会发生变换，他们还在原点（最后一列），并且x轴、y轴和z轴与视觉坐标中一样。
</p>
<p>  
  我们可以在OpenGL中这样生成一个单位矩阵：
</p>



<pre class="src src-c"><span style="color: #00ffff; font-weight: bold;">GLfloat</span> <span style="color: #ffd700; font-style: italic;">m</span>[] = { 1.0f, 0.0f, 0.0f, 0.0f,  <span style="color: #ffd700;">// </span><span style="color: #ffd700;">X Column</span>
                0.0f, 1.0f, 0.0f, 0.0f,  <span style="color: #ffd700;">// </span><span style="color: #ffd700;">Y Column</span>
                0.0f, 0.0f, 1.0f, 0.0f,  <span style="color: #ffd700;">// </span><span style="color: #ffd700;">Z Column </span>
                0.0f, 0.0f, 0.0f, 1.0f }; <span style="color: #ffd700;">// </span><span style="color: #ffd700;">Translation</span>
</pre>


<p>
  或者使用 math3d 的 <code>M3DMatrix44f</code> 类型：
</p>


<pre class="src src-c"><span style="color: #00ffff; font-weight: bold;">M3DMatrix44f</span> <span style="color: #ffd700; font-style: italic;">m</span> = { 1.0f, 0.0f, 0.0f, 0.0f,  <span style="color: #ffd700;">// </span><span style="color: #ffd700;">X Column</span>
                   0.0f, 1.0f, 0.0f, 0.0f,  <span style="color: #ffd700;">// </span><span style="color: #ffd700;">Y Column</span>
                   0.0f, 0.0f, 1.0f, 0.0f,  <span style="color: #ffd700;">// </span><span style="color: #ffd700;">Z Column </span>
                   0.0f, 0.0f, 0.0f, 1.0f }; <span style="color: #ffd700;">// </span><span style="color: #ffd700;">Translation</span>
</pre>


<p>
  在math3d库中还有一个快捷函数 <code>m3dLoadIdentity44</code> ，这个函数初始化一个空单位矩阵。
</p>




<pre class="src src-c"><span style="color: #00ffff; font-weight: bold;">void</span> <span style="color: #ffd700; font-weight: bold;">m3dLoadIdentity44</span>(<span style="color: #00ffff; font-weight: bold;">M3DMatrix44f</span> <span style="color: #ffd700; font-style: italic;">m</span>);
</pre>


<p>
  我们可以回忆一下，我们使用过的第一个存储（顶点）着色器就叫做<a href="./opengl_shadermanager.html#sec-3-1">单位着色器</a>。这个着色器完全不对顶点做任何改变，而是将这些顶点绘制在默认坐标系中，并且不在这些顶点上应用任何矩阵。
</p>
<p>
  加载单位矩阵意味着在顶点上不进行任何变换。从本质上来说，它相当于把模型视图矩阵重置回原点。
</p>
<p>
  变换函数的效果是累积性的。如果不希望前面的操作影响后面的变换，那就需要将模型视图矩阵重置为一个已知的状态。
</p>
<p>
  我们可以通过在模型视图矩阵中加载单位矩阵来实现把它重置到原点的目标。单位矩阵表示没有发生变换，加载单位矩阵的效果相当于在绘图时所指定的所有坐标都位于视觉坐标中。所谓单位矩阵，就是矩阵对角线的元素均为1,其余元素均为0的矩阵。当这种矩阵与任意顶点矩阵相乘时，其结果就是顶点矩阵不会发生改变。
</p>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 平移</h3>
<div class="outline-text-3" id="text-1-2">



<p>   
   一个平移矩阵仅仅是将我们的顶点沿着3个坐标中的一个或多个进行平移。
</p>
<p>
   我们可以调用math3d库中的 <code>m3dTranslationMatrix44</code> 函数来使用变换矩阵。
</p>



<pre class="src src-c"><span style="color: #00ffff; font-weight: bold;">void</span> <span style="color: #ffd700; font-weight: bold;">m3dTranslationMatrix44</span>(<span style="color: #00ffff; font-weight: bold;">M3DMatrix44f</span> <span style="color: #ffd700; font-style: italic;">m</span>, <span style="color: #00ffff; font-weight: bold;">float</span> <span style="color: #ffd700; font-style: italic;">x</span>, <span style="color: #00ffff; font-weight: bold;">float</span> <span style="color: #ffd700; font-style: italic;">y</span>, <span style="color: #00ffff; font-weight: bold;">float</span> <span style="color: #ffd700; font-style: italic;">z</span>);
</pre>


</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 旋转</h3>
<div class="outline-text-3" id="text-1-3">


<p>
   为了将一个对象沿着3个坐标轴中的一个或者任意向量进行旋转，需要找到一个旋转矩阵，又有一个math3d函数来帮助我们了。
</p>



<pre class="src src-c">m3dRotationMatrix44(<span style="color: #00ffff; font-weight: bold;">M3DMatrix44f</span> <span style="color: #ffd700; font-style: italic;">m</span>, <span style="color: #00ffff; font-weight: bold;">GLfloat</span> <span style="color: #ffd700; font-style: italic;">angle</span>, <span style="color: #00ffff; font-weight: bold;">GLfloat</span> <span style="color: #ffd700; font-style: italic;">x</span>, <span style="color: #00ffff; font-weight: bold;">GLfloat</span> <span style="color: #ffd700; font-style: italic;">y</span>, <span style="color: #00ffff; font-weight: bold;">GLfloat</span> <span style="color: #ffd700; font-style: italic;">z</span>;
</pre>


<p>
   在此，我们绕着由x、y和z参数所指定的向量执行旋转操作。旋转的角度就是angle参数所指定的度数（以 <b>弧度</b> 为单位， <b>逆时针方向</b> ）。在最简单的情况下，旋转是绕着其中一条轴进行的。
</p>
<p>
   我们也可以用x、y和z指定一个向量，让旋转围绕这个向量进行。为了观察旋转的角度，只需画一条由原点到点(x,y,z)的直线。下面的代码绕着向量(1,1,1)所指定的轴旋转45°。
</p>



<pre class="src src-c"><span style="color: #00ffff; font-weight: bold;">M3DMatrix44f</span> <span style="color: #ffd700; font-style: italic;">m</span>;
m3dRotationMatrix(m3dDegToRad(45.0), 1.0f, 1.0f, 1.0f);
</pre>


<p>
   注意在这个例子中 math3d 宏 <code>m3dDegToRad</code> 的使用。这个宏将角度换成弧度值。
</p>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> 缩放</h3>
<div class="outline-text-3" id="text-1-4">


<p>   
   缩放变换可以沿着3个坐标轴方向按照指定因子放大或缩小所有顶点，从而改变物体的大小。使用 math3d 库创建一个缩放矩阵，方法与创建平移或旋转矩阵的方法类似。
</p>



<pre class="src src-c"><span style="color: #00ffff; font-weight: bold;">M3DMatrix44f</span> <span style="color: #ffd700; font-style: italic;">m</span>;
<span style="color: #00ffff; font-weight: bold;">void</span> <span style="color: #ffd700; font-weight: bold;">m3dScaleMatrix44</span>(<span style="color: #00ffff; font-weight: bold;">M3DMatrix44f</span> <span style="color: #ffd700; font-style: italic;">m</span>, <span style="color: #00ffff; font-weight: bold;">float</span> <span style="color: #ffd700; font-style: italic;">xScale</span>, <span style="color: #00ffff; font-weight: bold;">float</span> <span style="color: #ffd700; font-style: italic;">yScale</span>, <span style="color: #00ffff; font-weight: bold;">float</span> <span style="color: #ffd700; font-style: italic;">zScale</span>);
</pre>


<p>
   缩放并不一定是一致的，可以在不同的方向上分别扩大或缩小物体。
</p>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> 综合变换</h3>
<div class="outline-text-3" id="text-1-5">



<p>   
   我们很少会只进行这些变换类型的一种。实际上，我们总是想同时进行这些变换。为了将对象移动到想要的位置，我们可能需要先将它平移到指定位置，然后再旋转到想要的方向。由于 \(4\times 4\)变换矩阵包含一个位置和一个方向，我们可能会想到，一个变换矩阵就可以完成这两种操作。我们是对的！
</p>
<p>
   将两种变换加在一起很简单，只需要将两个矩阵相乘（或者叫做“连接”）。不过在矩阵乘法中有一个小陷阱需要注意，就是运算的顺序是有影响的。例如，用一个旋转矩阵乘以一个平移矩阵，与用一个平移矩阵乘以一个旋转矩阵是不同的。
</p>
<p>
   math3d库函数 <code>m3dMatrixMultiply44</code> 用来将两个矩阵相乘并返回运算结果。
</p>



<pre class="src src-c"><span style="color: #00ffff; font-weight: bold;">void</span> <span style="color: #ffd700; font-weight: bold;">m3dMatrixMultiply44</span>(<span style="color: #00ffff; font-weight: bold;">M3DMatrix44f</span> <span style="color: #ffd700; font-style: italic;">product</span>, <span style="color: #00ffff; font-weight: bold;">const</span> <span style="color: #00ffff; font-weight: bold;">M3DMatrix44f</span> <span style="color: #ffd700; font-style: italic;">a</span>, <span style="color: #00ffff; font-weight: bold;">const</span> <span style="color: #00ffff; font-weight: bold;">M3DMatrix44f</span> <span style="color: #ffd700; font-style: italic;">b</span>);
</pre>


</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 运用模型视图矩阵</h2>
<div class="outline-text-2" id="text-2">


<p>
  运用模型视图矩阵，可以使用<a href="./opengl_shadermanager.html#sec-3-2">平面着色器</a>，接受 \(4\times 4\) 变换矩阵作为它的参数之一。
</p>



<pre class="src src-c">GLShaderManager::UseStockShader(GLT_SHADER_FLAT, <span style="color: #00ffff; font-weight: bold;">GLfloat</span> <span style="color: #ffd700; font-style: italic;">mvp</span>[16], <span style="color: #00ffff; font-weight: bold;">GLfloat</span> <span style="color: #ffd700; font-style: italic;">vColor</span>[4]); 
</pre>


<p>
  这个着色器在对图元进行渲染之前用每个向量乘以矩阵m。
</p>
<p>
  下面的示例程序是对<a href="./opengl_animation.html#sec-2">Move程序</a>的修改版，我们使用变量yPos和xPos来记录正方形的位置。现在可以方便的创建一个变换矩阵了。
</p>



<pre class="src src-c">m3dTranslationMatrix44(mTranslationMatrix, xPos, yPos, 0.0f);
</pre>


<p>
  然后，这个变换矩阵就可以在绘制之前被发送到着色器了，如下所示。
</p>



<pre class="src src-c">shaderManager.UseStockShader(GLT_SHADER_FLAT, mTranslationMatrix, vRed);
</pre>


<p>
  为了让事情更加有趣，我们在移动这个正方形的同时还对它进行了旋转。在xy平面中旋转这个正方形也包括围绕z轴旋转。下面程序演示了 Move 示例程序中的整个 <code>RenderScene</code> 函数。
</p>



<pre class="src src-c"><span style="color: #ffd700;">///////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #ffd700;">// </span><span style="color: #ffd700;">Called to draw scene</span>
<span style="color: #00ffff; font-weight: bold;">void</span> <span style="color: #ffd700; font-weight: bold;">RenderScene</span>(<span style="color: #00ffff; font-weight: bold;">void</span>)
{
  <span style="color: #ffd700;">// </span><span style="color: #ffd700;">Clear the window with current clearing color</span>
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

  <span style="color: #00ffff; font-weight: bold;">GLfloat</span> <span style="color: #ffd700; font-style: italic;">vRed</span>[] = { 1.0f, 0.0f, 0.0f, 1.0f };

  <span style="color: #00ffff; font-weight: bold;">M3DMatrix44f</span> <span style="color: #ffd700; font-style: italic;">mFinalTransform</span>, <span style="color: #ffd700; font-style: italic;">mTranslationMatrix</span>, <span style="color: #ffd700; font-style: italic;">mRotationMatrix</span>;

  <span style="color: #ffd700;">// </span><span style="color: #ffd700;">Just Translate</span>
  m3dTranslationMatrix44(mTranslationMatrix, xPos, yPos, 0.0f); <span style="color: #ffd700;">// </span><span style="color: #ffd700;">&#24179;&#31227;&#21464;&#25442;&#30697;&#38453;</span>

  <span style="color: #ffd700;">// </span><span style="color: #ffd700;">Rotate 5 degrees evertyime we redraw</span>
  <span style="color: #00ffff; font-weight: bold;">static</span> <span style="color: #00ffff; font-weight: bold;">float</span> <span style="color: #ffd700; font-style: italic;">yRot</span> = 0.0f;
  yRot += 5.0f;
  m3dRotationMatrix44(mRotationMatrix, m3dDegToRad(yRot), 0.0f, 0.0f, 1.0f); <span style="color: #ffd700;">// </span><span style="color: #ffd700;">&#26059;&#36716;&#21464;&#25442;&#30697;&#38453;</span>

  m3dMatrixMultiply44(mFinalTransform, mTranslationMatrix, mRotationMatrix); <span style="color: #ffd700;">// </span><span style="color: #ffd700;">&#20004;&#20010;&#21464;&#25442;&#30697;&#38453;&#30456;&#20056;&#65292;&#24471;&#21040;&#19968;&#20010;&#32508;&#21512;&#21464;&#25442;&#30697;&#38453;</span>

  shaderManager.UseStockShader(GLT_SHADER_FLAT, mFinalTransform, vRed); 
  squareBatch.Draw();

  <span style="color: #ffd700;">// </span><span style="color: #ffd700;">Perform the buffer swap</span>
  glutSwapBuffers();
}
</pre>


<p>
  平面着色器只接受一个矩阵变量，然后它会用这些顶点乘以这个矩阵。这个“模型视图”矩阵通过在默认坐标系中平移这些顶点来使我们的正方形在屏幕上移动，我们可以回忆一下，在这个坐标系中所有3个坐标轴范围都在 -1 和 +1 之间。然后，这个简单的坐标系并不是总能满足我们的需要，而且在更大的坐标空间中考虑我们的对象会更加方便。那么就可能会有另外一个矩阵能够允许我们将任何我们想要的坐标空间缩放到 -1 到 +1 的范围内。确实，这就是第二种类型的矩阵变换，称为投影，很快就会介绍相关内容。
</p>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-10-18 14:49:15 CST</p>
<p class="author">Author: Joseph Pan</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
